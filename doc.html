<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PlanList Service</title>
</head>
<body>


<h3>User Interface</h3>
<p>
    При открытии страницы вы видите свой список задач в режиме просмотра.
    Для переключения в режим редактирования,
    нужно нажать на кнопку Edit, кликнуть по плану двойным щелчком или нажать клавиши Ctrl+Enter или Ctrl+E.
    Чтобы выйти из режима редактирования,
    нужно нажать на кнопку Save, кликнуть на любом свободном месте или нажать клавиши Ctrl+Enter, Ctrl+S или Esc.
    При этом план будет сохранен на сервер.
</p>


<h3>Структура данных</h3>
<p>
    Все пользовательские данные накапливаются в папке data. Для каждого пользователя в нем свой каталог по его имени.
    Чтобы это работало, имя пользователя может содержать только определенные символы
    (сейчас это буквы всех алфавитов из unicode, цифры, пробел, дефис и подчеркивание), не может быть пустым.
    Имена также регистронечувствительны при проверке и хранятся все в нижнем регистре.
    В каждом пользовательском каталоге располагается файл password с паролем, файл plans с информацией обо всех планах
    и файл .txt с содержимым корневого плана.
    Содержимое остальных планов хранится в файлах вида path/plan_name.txt. То есть для дочерних планов путь пустой,
    они хранятся по соседству с корневым планом, для остальных создаются подпапки с именами родителей.
    Содержимое плана представляет из себя текст (в UTF-8, но думаю будет уместно UTF-16) в формате для скрипта planlist.js
    (который строит по нему html).
    У каждого плана есть поля (файл plans):
</p>
<ul>
    <li>name - имя плана, накладываются такие же ограничения, как и на имя пользователя,  плюс не может содержать пробелы,
        также хранится в нижнем регистре, не может быть пустым</li>
    <li>title - отображаемое название, не может содержать табуляцию и перенос строки</li>
</ul>
<h5>Пароли</h5>
<p>
    Со стороны клиента пароль хешируется алгоритмом PBKDF2, то есть сервер принимает только хешированный пароль от клиента.
    Это дает хоть какую-то защиту без HTTPS (пароль будет сложно расшифровать, но сохраняется уязвимость к атакам "человек посередине")
    На стороне сервера пароль еще раз хешируется перед сохранением в файл или сравнением с сохраненным значением
    (стандартная защита на случай, если вдруг злоумышленник получит доступ к файлам паролей с сервера).
</p>


</body>
</html>